
[TOC]

> 数据表中字段是不区分大小写的
##  在程序中直接调用自动建表

```
// 数据库别名
name := "default"

// drop table 后再建表
force := true

// 打印执行过程
verbose := true

// 遇到错误立即返回
err := orm.RunSyncdb(name, force, verbose)
if err != nil {
    fmt.Println(err)
}
```

## 返回值设定
1. Values  返回带自带名的 数组
```
var param []orm.Params
_, e := o.Raw("sql 语句").Values(&param)
beego.Debug(param)  // [map[order_id:1 dept_id:1 dept_parent_id: name:指挥导控系统]]
```
2. ValuesList   返回不带字段名的数组
```
var param []orm.ParamsList
_, e := o.Raw("sql 语句").ValuesList(&param)
beego.Debug(param) //[[1  指挥导控系统 1]]
```
3. ValuesFlat
```
var param orm.ParamsList
_, e := o.Raw("sql 语句").ValuesFlat(&param)
beego.Debug(param) // [1  指挥导控系统 1]
```

## 数据库操作
## CRUD  查询

### 查
```
//查默认通过主键
user := HsUser{UserId: 146}
err := o.Read(&user)
fmt.Println(user)

//指定查询条件
user := HsUser{UserName: "aaa", UserLogin: "aaa1"}
err := o.Read(&user, "user_name", "user_login")
fmt.Println(user)
```
### 增
1. 单个更新
```
user.Name = "slene"
user.IsActive = true
id, err := o.Insert(&user)
```
2. 多个更新
```
users := []User{
    {Name: "slene"},
    {Name: "astaxie"},
    {Name: "unknown"},
    ...
}
//第一个参数 bulk 为并列插入的数量，第二个为对象的slice
//bulk 为 1 时，将会顺序插入 slice 中的数据
successNums, err := o.InsertMulti(100, users)
```
### 更新

```
//1. 更新所有字段
user.UserName="update_pvj1"
i, err := o.Update(&user) 

//2.更新指定字段
user.UserName="update_pvj1"
Update(&user,"user_name",...)   
```
## 删除
```go
o.Delete(&User{Id: 1})
```

## 高级查询
```go
// 获取 QuerySeter 对象，user 为表名
qs := o.QueryTable("user")

// 也可以直接使用对象作为表名
user := new(User)
qs = o.QueryTable(user) // 返回 QuerySeter
```


## 关系性数据库需要注意
### 一对一情况关联表
如:
```
方式一 : 
[user]  id name  user_data_id

[user_data]  id address

方式二:
[user]  id name  

[user_data]  id address  user_id
```
> 注意: 创建`struct` 时 把有对方 `user_id `的表 为 `rel(one)`

#### 针对方式一的操作
```go
//==========表==========
[user]  id name profile_id
[profile] id age
//==========表==========

// ==========  结构体==========
type User struct {
	Id      int
	Name    string
	Profile *Profile `orm:"rel(one)"`      // OneToOne relation
}

type Profile struct {
	Id   int
	Age  int16
	User *User `orm:"reverse(one)"` // 设置一对一反向关系(可选)
}
// ==========  结构体==========



//==========已经取得了 User 对象，查询 Profile==========
user := &User{Id: 1}
o.Read(user)
if user.Profile != nil {
    o.Read(user.Profile)
}

//==========直接关联查询==========
user := &User{}
o.QueryTable("user").Filter("Id", 1).RelatedSel().One(user)

// 自动查询到 Profile
fmt.Println(user.Profile)
//可正常取值
fmt.Println(user.Profile.User) 

//==========通过 User 反向查询 Profile==========
var profile Profile
err := o.QueryTable("profile").Filter("User__Id", 1).One(&profile)
if err == nil {
    fmt.Println(profile)
}
```
#### 针对方式二的操作
```

```


> 注意: 在`user` 表的strcut 表中 无需声明`profile_id`  关联表时就指定,可自定义
`Profile *Profile `orm:"rel(one);column(profile_id)"`