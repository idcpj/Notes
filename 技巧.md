[TOC]

## 类型别名
类型别名不能进行计算
```
type a int16  //定义 a 为 int16 
func main() {
	 var abc a  //定义 abc 为 a 类型
	 fmt.Print(unsafe.Sizeof(abc)) //2 
}
```
## 打印结构类型或自动打印类型
使用`%v`
```
a := [][]int{
    {1,2,3},
    {1,2,3},
}
fmt.Printf("%v",a) //[[1 2 3] [1 2 3]]

//识别 字符串和整形
b :=1
c :="a"
fmt.Printf("%v",b) 
fmt.Printf("%v",c)
```
## 应用结构化后的值
```
type User struct{
    engine *xorm.Engine
}
func User(engine *xorm.Engine) *User(){
    return &User(){
        engine *xorm.Engine
    }
}
```

## 保持 go 自持运行
1. 监听一个端口
添加一个 端口监听 并且设置一个借口为 `/ping` 返回 pong 
这样既可以保持运行.又可以检测是否运行
```
http.HandleFunc("/ping", func(w http.ResponseWriter, r *http.Request) {
	io.WriteString(w,"pong")
})

http.ListenAndServe(":9193",nil)
```
## 遍历一个chan
通过一个 for 循环
```
for k,v :=range chan_anme{
//code
}
```

##   slice,chan,map 无需进行引用,就可实现传值
map
```
// map 类型不需要引用传值
func demo(a map[int]string) {
	a[11] = "123"
}
func main() {
	a := make(map[int]string)
	a[21] = "asd"
	demo(a)

	fmt.Println(a) //map[21:asd 11:123]
}
```
chan
```
func main() {

	person := make(chan int, 10)
	modify(person)
	fmt.Println(<-person) //12
	time.Sleep(23 * time.Second)
}

func modify(p chan int) {
	p <- 12
}
```
## 指针
```
func main() {
	i := 10
	ip := &i
	fmt.Printf("原始指针的内存地址是：%p\n", &ip) //0xc042072018
	modify(ip)
	fmt.Println("int值被修改了，新值为:", i) //1
}

func modify(ip *int) {
	fmt.Printf("函数里接收到的指针的内存地址是：%p\n", &ip) //0xc042072028
	*ip = 1
}
```

##  匿名嵌入的方式实现继承
```
type person struct {
	Name string
}
type foo struct {
	person //匿名嵌入的方式实现继承
}
func main() {
	Foo := foo{}
	Foo.Name="asd"
}
```
## 实现 String() 接口的结构体
实现了 String(),可在打印时,自定义输出的字符串`fmt.Printlln(foo)`

