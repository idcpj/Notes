[TOC]

## 类型别名
类型别名不能进行计算
```
type a int16  //定义 a 为 int16 
func main() {
	 var abc a  //定义 abc 为 a 类型
	 fmt.Print(unsafe.Sizeof(abc)) //2 
}
```
## 打印结构类型或自动打印类型
使用`%v`
```
a := [][]int{
    {1,2,3},
    {1,2,3},
}
fmt.Printf("%v",a) //[[1 2 3] [1 2 3]]

//识别 字符串和整形
b :=1
c :="a"
fmt.Printf("%v",b) 
fmt.Printf("%v",c)
```
## 应用结构化后的值
```
type User struct{
    engine *xorm.Engine
}
func User(engine *xorm.Engine) *User(){
    return &User(){
        engine *xorm.Engine
    }
}
```

## 保持 go 自持运行
1. 监听一个端口
添加一个 端口监听 并且设置一个借口为 `/ping` 返回 pong 
这样既可以保持运行.又可以检测是否运行
```
http.HandleFunc("/ping", func(w http.ResponseWriter, r *http.Request) {
	io.WriteString(w,"pong")
})

http.ListenAndServe(":9193",nil)
```
## 遍历一个chan
通过一个 for 循环
```
for k,v :=range chan_anme{
//code
}
```

##   slice,chan,map 无需进行引用,就可实现传值
map
```
// map 类型不需要引用传值
func demo(a map[int]string) {
	a[11] = "123"
}
func main() {
	a := make(map[int]string)
	a[21] = "asd"
	demo(a)

	fmt.Println(a) //map[21:asd 11:123]
}
```
chan
```
func main() {

	person := make(chan int, 10)
	modify(person)
	fmt.Println(<-person) //12
	time.Sleep(23 * time.Second)
}

func modify(p chan int) {
	p <- 12
}
```
## 指针
```
func main() {
	i := 10
	ip := &i
	fmt.Printf("原始指针的内存地址是：%p\n", &ip) //0xc042072018
	modify(ip)
	fmt.Println("int值被修改了，新值为:", i) //1
}

func modify(ip *int) {
	fmt.Printf("函数里接收到的指针的内存地址是：%p\n", &ip) //0xc042072028
	*ip = 1
}
```

##  匿名嵌入的方式实现继承
```
type person struct {
	Name string
}
type foo struct {
	person //匿名嵌入的方式实现继承
}
func main() {
	Foo := foo{}
	Foo.Name="asd"
}
```
## 实现 String() 接口的结构体
实现了 String(),可在打印时,自定义输出的字符串`fmt.Printlln(foo)`

## 条件编译
目录结构
```
├─echo
    ├─echo1.go
    └─echo2.go
└─main.go
```
echo1.go
```
// +build !echo2
package echo
func Echo() {
	fmt.Println("echo1.go")
}
```

echo2.go
```
// +build echo2
package echo
func Echo() {
	fmt.Println("echo1.go")
}
```
main.go
```
func main() {
	echo.Echo()
}
```
```
go build -tags=echo2 main.go  && main.exe   //output    echo2.go
go build  main.go  && main.exe      //output    echo1.go
```
## 只初始化一次变量,如链接数据库
定义全局指针变量,在 init 中进行赋值
```
var (
	dbConn *sql.DB
	err error
)

func init(){
	dbConn,err=sql.Open("mysql","root:12345678@tcp(localhost:3306)/video_server?charset=utf8")
	if err!=nil{
		panic(err)
	}
	err =dbConn.Ping()
	if err!=nil {
		panic(err)
	}
}
```
## sync.map
并发安全的 map
```
//存
func (m *Map) Store(key, value interface{})
//取
func (m *Map) Load(key interface{}) (value interface{}, ok bool
//删
func (m *Map) Delete(key interface{})
```