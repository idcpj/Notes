[TOC]

## 统一在函数头声明变量
```
func demo() {
	var(
		data string
		err error
	)
	//code
}
```

## 函数的 error 返回值
```
func main() {
	data, err := demo()
	fmt.Println(err)
	fmt.Println(data)
}
//在函数中,不需要在return 中添加返回值,只要变量相同,即可
func demo() (data string, err error) {
	data = "asd"
	err = errors.New("hello")
	return
}
```
## 通过 reflect 判断 interface{} 的类型与值
```
var a interface{}
a = "13"
fmt.Println(reflect.ValueOf(a))//a
```

##  创建不分类型的数组和 map
```
//interface 可创任意类型的数组
a :=[]interface{}{"a",1,"b"}
fmt.Print(a[0])//a

//interface 可创任意类型的map
b :=map[interface{}]interface{}{"asd":132,123:"asasd"}
fmt.Print(b[123]) //asasd
```


## 用 switch 判断类型
```
var a  interface{}
a=3
switch a.(type) {
case int:
    fmt.Print("int ")
    break
case string:
    fmt.Print("string")
    break
default:
    fmt.Print("not kome")
}
```

## select 用法
```
ch4 := make(chan int, 1)
for i := 0; i < 4; i++ {
    select {
    case e, ok := <-ch4:
        if !ok {
            fmt.Println("End.")
            return
        }
        fmt.Println(e)
        close(ch4)    //关闭 channel

    default:
        fmt.Println("No Data!")
        ch4<-1
    }
}

/*输出
No Data!
1
End.
*/
```



## var 与 new 区别
```
p := new(person)
err := xml.Unmarshal(str, p)

//同

var p person
err := xml.Unmarshal(str, &p)
```
> 对于new 相当于分配引用类型的内存地址,并且赋值,而 var 只分配内存,没有赋值

```
var c *int
*c = 10
fmt.Println(*c)  //会报错

/*====*/

b := new(int)
*b = 10
fmt.Println(*b)  //10 
```
## new 与 make 的区别
`make` 只创建 `chan`、`map`以及切片的内存创建


## 将interface{} 值转为 struct 数组,用可用从数组中取值
方法一:
```
type Foo struct {
	Name   string `json:"name"`
	TestId int    `json:"test_id"`
}

func main() {
	foo := &Foo{}
	a := map[string]interface{}{"name": "cpj", "age": 1, "test_id": 123456}
	d, _ := json.Marshal(a)
	json.Unmarshal(d, &foo)

	fmt.Println(foo) //&{cpj 123456}
}
```
## 在函数体内定义struct
```
var Foo = struct {
	Name   string `json:"name"`
	Age    int    `json:"age"`
	TestId int    `json:"test_id"`
}{}  //需定以后立即实例化
//code...
_ = json.Unmarshal(bytes, &Foo)
```

## 引用传值的技巧
```
UserList := new(userList)  
//相同 UserList := &userList{}
go connHandler(conn, UserList)
func connHandler(c net.Conn, UserList *userList) {}

//等同于

UserList := userList{}
go connHandler(conn, UserList)
func connHandler(c net.Conn, UserList *userList) {}
```






